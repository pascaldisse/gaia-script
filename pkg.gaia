ℙ⟨
  µ⟨⊹.⋰⟩
  τ⟨⋮⋰⋮⋱⊹⋮⋱⋰⋱⟩
  ƒ⟨
    ⚡⟨main.gaia⟩⟨
      N〈υ⊕η⊕Γ⊕μ⊕∂⊕ℝ〉
      ⊛⟪ℝ⟫ℝΘ⊛⟪/ℝ⟫
      ℝ〈Þ⊕¢⊕Ħ〉
      Þ⟪₦⟫ÞΘ✧ϖ¥μ✧ϖℵ✧ΦϒÞ⟪/₦⟫
      Þ:{⊹:0,⊿:1,⋮:2,⋰:3,⋱:4,⌓:5,⌗:6,⊥:7,⊢:8,⊧:9,⋈:10,≡:100,≢:1000,≋:10000,⋕:100000,Ⅰ:-1,Ⅱ:-2,Ⅲ:-3,Ⅳ:-4,Ⅴ:-5,Ⅵ:-6,Ⅶ:-7,Ⅷ:-8,Ⅸ:-9,Ⅹ:-10}
      ¢⟪⚄⟫¢β✧φβ✧ℵν✧τℵ¢⟪/⚄⟫
      ¢:{⊹⊿:1,⊹⋮:2,⊹⋰:3,⊹⋱:4,⊹⌓:5,⊿⊹:10,⋮⊹:20,⋰⊹:30,⋱⊹:40,⌓⊹:50,⊿⊿:11,⋮⋮:22,⋰⋰:33,⋱⋱:44,⌓⌓:55,⊹ᴧ¹:0.1,⊹ᴧ²:0.01,⊹ᴧ³:0.001,⊿ᴧ¹:1.1,⋮ᴧ²:2.01}
      Ħ⟪⚂⟫Ħζ✧≡φ✧Φϵ✧φΦτĦ⟪/⚂⟫
      Ħ:{⊿̇:√1,⋮̇:√2,⋰̇:√3,⋱̇:√4,⌓̇:√5,⊿̈:1²,⋮̈:2²,⋰̈:3²,⋱̈:4²,⌓̈:5²,⊿̂:2¹,⋮̂:2²,⋰̂:2³,⋱̂:2⁴,⌓̂:2⁵,⊿̃:π,⋮̃:2π,⋰̃:e,⋱̃:φ,⌓̃:⅟π}
      ⊛⟪υ⟫υΦκ⊛⟪/υ⟫
      υ〈§⊕γ⊕δ⊕α〉
      §⟪Θ⟫Θ∥§⟪/Θ⟫
      §:Σ→⍚→⚡→Ω
      γ⟪Κ⟫υΚΘ✧ϖϱωι✧≈κϵγ⟪/Κ⟫
      γ:⟨{ϖ,ϖł,ϱ}⟩→∮⌗≡×⊧≡→П→⊞⋰×⋰→[(⌘"▶"⌘ω→φ.①),(⌘"↺"⌘ω→φ.⓪),(⌑"§"⇄φ.ς)]
      δ⟪ℵ⟫ℵΚ✧Σℵ✧Διυ✧Σϖ≈δ⟪/ℵ⟫
      δ:⟨{ϖ:⟨ℵ:⊹⟩,ϖł:⟨ϕ:⟨ρ:⋮⊹ξ,λ:ς,δ:φ,φΔ:ϕ⟩,ξ:⟨χ:#fff,β:#336,μ:⌓ξ,ω:⋱⊹ξ,ζ:⋱ξ,ξς:⊿⌗ξ⟩,ϑ:⟨ξς:⋮⋱ξ,χ:#222,μ:⊿⊹ξ,ξβ:β⟩⟩,ϱ:⟨П→⊞⋰×⊿→[(⌘"Ⅰ"⌘ω→ℵ⊝),(⌑"ℵ:${ℵ}"⇄ℵ),(⌘"⊿"⌘ω→ℵ⊕)]⟩}⟩
      α⟪Ξ⟫Ξ/ϒΘ✧Δϒτ✧ΨΘ✧μΞα⟪/Ξ⟫
      α:⊿→⍉→◐→⌼→☀→⊠→⊛
      ⊛⟪η⟫ηΚ⊛⟪/η⟫
      η〈Ñ⊕Ŧ⊕Ğ〉
      ⟡⟪Ñ⟫Ñη✧Ϊζ✧Ϥε✧⋮≡×⋮≡RGBι⟡⟪/Ñ⟫
      Ñ:I⋮≡×⋮≡×⋰→C₁⋰⋮→P→C₂⊧⋱→P→F→D₁⊿⋮⌗→D₂⊧⋱→D₀⊿⊹→S
      ⟡⟪Ŧ⟫Ŧϖ✧Σϭ✧Δϖ✧Θ-Ξζ⟡⟪/Ŧ⟫
      Ŧ:T⇀E⌓⊿⋮+P→[H⌗A→N→F⋮⊹⋱⌗→D⊹ᴧ¹]×⊧→D₁⊿⊹⋮⋱R→D₀V→S
      ⟡⟪Ğ⟫ĞΔη✧Ϊψ✧Δτ✧Ğϵρϱ⟡⟪/Ğ⟫
      Ğ〈G⊕D⊕L〉
      G:Z⊿≡→U⋰×⋰×⌓⊿⋮→[U⋮×→C⋮⌓⊧ρ]×⋮→C⋰τ
      D:I→[C⊧⋱⌓ρ→P⋮]×⋰→F→D₁⊿⊹⋮⋱ρ→D₀⊿σ
      L:G(Z)⊳D⟿BCE+λ‖∇D‖
      ⊛⟪Γ⟫ΓΘΚ⊛⟪/Γ⟫
      Γ〈G⊕W⊕M⊕C〉
      ♦⟪G⟫Γϟ✧Өιϖ✧Γϖ≈✧Δ≈♦⟪/G⟫
      G:I→C⋰⋮⋰ρ→P⋮→F→D₁⊿⋮⌗ρ→D₀⊥→S
      ♦⟪W⟫ωϖ✧Өτ✧Ξϕ✧Ϛα≈♦⟪/W⟫
      W:Z⌓⊿⋮→U⊿⊧×⊿⊧×⋰⋮→C⊧⋱⋰ρ→U⋮×→C⋰⋮⋰ρ→R
      ♦⟪M⟫μϖΘ✧Φμ✧Δτ✧Ϥι♦⟪/M⟫
      M:Z⊿⋮⌗→D₁⊧⋱ρ→D₁⋰⋮ρ→R⋱×⋱×⋮→U⋮×→C⌗⋰ρ
      ♦⟪C⟫ϾΘ✧βϖ✧Δζ✧ωϖΞ♦⟪/C⟫
      C:M⊳G⟿MSE
      ⊛⟪μ⟫μΞΘ⊛⟪/μ⟫
      μ:φ:⦿→⌖→[T⊿⊹→L⋮⊹→P→D⋰⋮→τ]×⋰→⟲⊧⊹
      ⊛⟪∂⟫∂Θ⊛⟪/∂⟫
      ∂〈⛯⊕⌰⊕⚑⊕⚙〉
      ⛯⟪Λ⟫∂ΛΘ✧Φ∂β✧ϖ-ϱΞ✧ζζ⛯⟪/Λ⟫
      ⛯:⛯⟪Π⟫ϕ⛯⟪/Π⟫→★⟪Δ⟫δ★⟪/Δ⟫
      ⌰⟪Ϛ⟫ϚΘ✧λΞ✧ζ∂✧ϱϑϲ⌰⟪/Ϛ⟫
      ⌰:◉ζ:τ◉→⚐ϱ:τ→⚛ξ⚛→⚠ς⚠
      ⚑⟪Ϟ⟫ϞΘ✧ϰζ✧Κζ✧ϱ≈⚑⟪/Ϟ⟫
      ⚑:⦾ϵ⦾→⦿ϐ⦿→⧇ϱ⧇
      ⚙⟪λ⟫λ∂✧ϡϖδ✧ζτΞ✧ξξ⚙⟪/λ⟫
      ⚙:λ⟪θ⟫◉ι:τ◉→⚐τ:τ→⚛ξ⚛
      ⋙Ψ∬Ω
    ⟩
    ⚡⟨comp/compiler.js⟩⟨
      w₄₀.env.NODE_ENV = w₄₀.env.NODE_ENV w₁₇ 'development';
      
      w₊₂ fs = w₈₇('fs');
      w₊₂ path = w₈₇('path');
      w₊₂ { spawnSync } = w₈₇('child_process');
      
      // GaiaScript compiler
      s₍₁₁₎{
        /**
         * Compile GaiaScript to JavaScript
         * @param {string} gaiaCode - GaiaScript code
         * @returns {string} JavaScript code
         */
        compile(gaiaCode) {
          try {
            // Create temp files
            w₊₂ tempInputPath = path.join(w₄₀.cwd(), '.temp-gaia-input.gaia');
            w₊₂ tempOutputPath = path.join(w₄₀.cwd(), '.temp-gaia-output.js');
            
            // Write input
            fs.writeFileSync(tempInputPath, gaiaCode);
            
            // Run parser and transformer
            w₊₂ result = this.parseAndTransform(gaiaCode);
            
            // Write output
            fs.writeFileSync(tempOutputPath, result);
            
            // Delete temp input
            try {
              fs.unlinkSync(tempInputPath);
            } catch (err) {}
            
            w₊₁ result;
          } catch (error) {
            w₊₁ `console.error("Compilation error: ${error.message}");\n`;
          }
        },
        
        /**
         * Parse and transform GaiaScript code
         * @param {string} gaiaCode - GaiaScript code
         * @returns {string} JavaScript code
         */
        parseAndTransform(gaiaCode) {
          // Simple transformer that converts a subset of GaiaScript to JS
          w₊₃ jsCode = '';
          
          // Convert network definitions
          jsCode += 'function initGaiaUI(container) {\n';
          jsCode += '  console.log("GaiaScript UI initialized");\n';
          jsCode += '  container.innerHTML = "<div>GaiaScript App</div>";\n';
          
          // Extract neural network definition
          w₊₂ networkMatch = gaiaCode.match(/N\s+I\s+→\s+([^S]+)S/);
          s₍₄₎(networkMatch) {
            jsCode += '  console.log("Neural network detected");\n';
            jsCode += '  const network = {\n';
            jsCode += '    input: "I",\n';
            jsCode += '    layers: []\n';
            jsCode += '  };\n';
            
            // Extract layers
            w₊₂ layerRegex = /([CD][₀₁₂])\s+(\d+)(?:\s+(\d+))?\s+([ρστ])?/g;
            w₊₃ layerMatch;
            w₊₃ layers = [];
            
            while ((layerMatch = layerRegex.exec(networkMatch[1])) !== null) {
              w₊₂ layerType = layerMatch[1];
              w₊₂ units = layerMatch[2];
              w₊₂ kernelSize = layerMatch[3] || null;
              w₊₂ activation = layerMatch[4] || null;
              
              jsCode += `  network.layers.push({ type: "${layerType}", units: ${units}`;
              s₍₄₎(kernelSize) {
                jsCode += `, kernelSize: ${kernelSize}`;
              }
              s₍₄₎(activation) {
                jsCode += `, activation: "${activation}"`;
              }
              jsCode += ' });\n';
            }
          }
          
          // Handle UI components
          s₍₄₎(gaiaCode.includes('υ〈')) {
            jsCode += '  // UI Components\n';
            jsCode += '  const button = document.createElement("button");\n';
            jsCode += '  button.textContent = "Run";\n';
            jsCode += '  button.className = "play";\n';
            jsCode += '  button.addEventListener("click", () => {\n';
            jsCode += '    console.log("Button clicked");\n';
            jsCode += '  });\n';
            jsCode += '  container.appendChild(button);\n';
          }
          
          jsCode += '}\n\n';
          
          // Export functions
          jsCode += 'if (typeof module !== "undefined") {\n';
          jsCode += '  module.exports = { initGaiaUI };\n';
          jsCode += '}\n';
          
          w₊₁ jsCode;
        }
      };
    ⟩
    ⚡⟨docs/README.md⟩⟨
      # GaiaScript
      
      GaiaScript is an ultra-compact symbolic language designed for minimal token usage in AI-to-AI communication.
      
      ## Quick Start
      
      ```bash
      ./gaia run main.gaia
      ```
      
      ## Basic Example
      
      ```
      N I → C₁ 32 3 ρ → P 2 → F → D₁ 128 ρ → D₀ 10 → S
      ```
      
      This defines a convolutional neural network with:
      - Input layer (I)
      - Conv layer with 32 filters, 3x3 kernel, ReLU activation (C₁ 32 3 ρ)
      - Max pooling layer with 2x2 window (P 2)
      - Flatten layer (F)
      - Dense layer with 128 units and ReLU activation (D₁ 128 ρ)
      - Output layer with 10 units (D₀ 10)
      - Softmax activation (S)
      
      ## UI Elements
      
      ```
      υ〈§⊕γ⊕δ⊕α〉
      γ:⟨{ϖ,ϖł,ϱ}⟩→∮⌗≡×⊧≡→П→⊞⋰×⋰→[(⌘"▶"⌘ω→φ.①),(⌘"↺"⌘ω→φ.⓪)]
      ```
      
      This defines a UI with playback controls.
    ⟩
  ⟩
  ⚙⟨
    w₊₂ fs = w₈₇('fs');
    w₊₂ path = w₈₇('path');
    w₊₂ zlib = w₈₇('zlib');
    
    s₍₁₁₎{
      /**
       * Decompress GaiaScript package
       * @param {string} pkgPath - Path to pkg.gaia file
       * @param {string} outputDir - Directory to extract to
       */
      extract(pkgPath, outputDir = '.') {
        s₍₄₎(!fs.existsSync(pkgPath)) {
          s₍₃₎(`Package not found: ${pkgPath}`);
          w₊₁ false;
        }
        
        // Read package
        w₊₂ content = fs.readFileSync(pkgPath, 'utf-8');
        
        // Validate package
        s₍₄₎(!content.startsWith('ℙ⟨')) {
          s₍₃₎('Invalid package format');
          w₊₁ false;
        }
        
        // Parse package
        w₊₂ pkg = this.parsePackage(content);
        
        // Extract files
        s₍₄₎(!fs.existsSync(outputDir)) {
          fs.mkdirSync(outputDir, { recursive: true });
        }
        
        // Process files
        w₊₈ of pkg.files) {
          w₊₂ outputPath = path.join(outputDir, file.path);
          w₊₂ outputDirPath = path.dirname(outputPath);
          
          // Create directory if needed
          s₍₄₎(!fs.existsSync(outputDirPath)) {
            fs.mkdirSync(outputDirPath, { recursive: true });
          }
          
          // Write file
          fs.writeFileSync(outputPath, file.content);
          s₍₃₎(`Extracted: ${file.path}`);
        }
        
        s₍₃₎(`Extracted ${pkg.files.length} files to ${outputDir}`);
        w₊₁ true;
      },
      
      /**
       * Parse GaiaScript package
       * @param {string} content - Package content
       * @returns {Object} Parsed package
       */
      parsePackage(content) {
        // Extract sections
        w₊₂ versionMatch = content.match(/µ⟨(.+?)⟩/);
        w₊₂ timestampMatch = content.match(/τ⟨(.+?)⟩/);
        w₊₂ filesSection = content.match(/ƒ⟨([\s\S]+?)⟩/);
        
        s₍₄₎(!versionMatch || !timestampMatch || !filesSection) {
          throw new Error('Invalid package format');
        }
        
        w₊₂ version = versionMatch[1];
        w₊₂ timestamp = timestampMatch[1];
        w₊₂ filesContent = filesSection[1];
        
        // Parse files
        w₊₂ fileRegex = /⚡⟨([^⟩]+)⟩⟨([\s\S]+?)⟩/g;
        w₊₂ files = [];
        w₊₃ fileMatch;
        
        while ((fileMatch = fileRegex.exec(filesContent)) !== null) {
          files.push({
            path: fileMatch[1],
            content: fileMatch[2]
          });
        }
        
        w₊₁ {
          version,
          timestamp,
          files
        };
      },
      
      /**
       * Run GaiaScript compiler
       * @param {string} inputFile - GaiaScript file path
       * @param {Object} options - Compiler options
       */
      run(inputFile, options = {}) {
        // Extract package to temp dir
        w₊₂ tempDir = path.join(w₄₀.cwd(), '.gaia-temp');
        this.extract('./pkg.gaia', tempDir);
        
        // Read input file
        w₊₂ gaiaCode = fs.readFileSync(inputFile, 'utf-8');
        
        // Load compiler
        w₊₂ compiler = w₈₇(path.join(tempDir, 'comp/compiler.js'));
        
        // Compile
        w₊₂ jsCode = compiler.compile(gaiaCode);
        
        // Output
        w₊₂ outputPath = options.output || 'gaia-compiled.js';
        fs.writeFileSync(outputPath, jsCode);
        
        s₍₃₎(`Compiled ${inputFile} to ${outputPath}`);
        
        // Cleanup
        this.cleanup(tempDir);
        
        w₊₁ true;
      },
      
      /**
       * Clean up temporary files
       * @param {string} tempDir - Temporary directory
       */
      cleanup(tempDir) {
        s₍₄₎(fs.existsSync(tempDir)) {
          w₊₂ { execSync } = w₈₇('child_process');
          try {
            execSync(`rm -rf ${tempDir}`);
          } catch (error) {
            s₍₃₎(`Warning: Could not clean up temporary directory: ${error.message}`);
          }
        }
      }
    };
  ⟩
⟩