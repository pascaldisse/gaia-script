ℙ⟨
  µ⟨⊹.⋰⟩
  τ⟨⋮⋰⋮⋱⊹⋮⋱⋰⋱⟩
  ƒ⟨
    ⚡⟨main.gaia⟩⟨
      N〈υ⊕η⊕Γ⊕μ⊕∂⊕ℝ〉
      ⊛⟪ℝ⟫ℝΘ⊛⟪/ℝ⟫
      ℝ〈Þ⊕¢⊕Ħ〉
      Þ⟪₦⟫ÞΘ✧ϖ¥μ✧ϖℵ✧ΦϒÞ⟪/₦⟫
      Þ:{⊹:0,⊿:1,⋮:2,⋰:3,⋱:4,⌓:5,⌗:6,⊥:7,⊢:8,⊧:9,⋈:10,≡:100,≢:1000,≋:10000,⋕:100000,Ⅰ:-1,Ⅱ:-2,Ⅲ:-3,Ⅳ:-4,Ⅴ:-5,Ⅵ:-6,Ⅶ:-7,Ⅷ:-8,Ⅸ:-9,Ⅹ:-10}
      ¢⟪⚄⟫¢β✧φβ✧ℵν✧τℵ¢⟪/⚄⟫
      ¢:{⊹⊿:1,⊹⋮:2,⊹⋰:3,⊹⋱:4,⊹⌓:5,⊿⊹:10,⋮⊹:20,⋰⊹:30,⋱⊹:40,⌓⊹:50,⊿⊿:11,⋮⋮:22,⋰⋰:33,⋱⋱:44,⌓⌓:55,⊹ᴧ¹:0.1,⊹ᴧ²:0.01,⊹ᴧ³:0.001,⊿ᴧ¹:1.1,⋮ᴧ²:2.01}
      Ħ⟪⚂⟫Ħζ✧≡φ✧Φϵ✧φΦτĦ⟪/⚂⟫
      Ħ:{⊿̇:√1,⋮̇:√2,⋰̇:√3,⋱̇:√4,⌓̇:√5,⊿̈:1²,⋮̈:2²,⋰̈:3²,⋱̈:4²,⌓̈:5²,⊿̂:2¹,⋮̂:2²,⋰̂:2³,⋱̂:2⁴,⌓̂:2⁵,⊿̃:π,⋮̃:2π,⋰̃:e,⋱̃:φ,⌓̃:⅟π}
      ⊛⟪υ⟫υΦκ⊛⟪/υ⟫
      υ〈§⊕γ⊕δ⊕α〉
      §⟪Θ⟫Θ∥§⟪/Θ⟫
      §:Σ→⍚→⚡→Ω
      γ⟪Κ⟫υΚΘ✧ϖϱωι✧≈κϵγ⟪/Κ⟫
      γ:⟨{ϖ,ϖł,ϱ}⟩→∮⌗≡×⊧≡→П→⊞⋰×⋰→[(⌘"▶"⌘ω→φ.①),(⌘"↺"⌘ω→φ.⓪),(⌑"§"⇄φ.ς)]
      δ⟪ℵ⟫ℵΚ✧Σℵ✧Διυ✧Σϖ≈δ⟪/ℵ⟫
      δ:⟨{ϖ:⟨ℵ:⊹⟩,ϖł:⟨ϕ:⟨ρ:⋮⊹ξ,λ:ς,δ:φ,φΔ:ϕ⟩,ξ:⟨χ:#fff,β:#336,μ:⌓ξ,ω:⋱⊹ξ,ζ:⋱ξ,ξς:⊿⌗ξ⟩,ϑ:⟨ξς:⋮⋱ξ,χ:#222,μ:⊿⊹ξ,ξβ:β⟩⟩,ϱ:⟨П→⊞⋰×⊿→[(⌘"Ⅰ"⌘ω→ℵ⊝),(⌑"ℵ:${ℵ}"⇄ℵ),(⌘"⊿"⌘ω→ℵ⊕)]⟩}⟩
      α⟪Ξ⟫Ξ/ϒΘ✧Δϒτ✧ΨΘ✧μΞα⟪/Ξ⟫
      α:⊿→⍉→◐→⌼→☀→⊠→⊛
      ⊛⟪η⟫ηΚ⊛⟪/η⟫
      η〈Ñ⊕Ŧ⊕Ğ〉
      ⟡⟪Ñ⟫Ñη✧Ϊζ✧Ϥε✧⋮≡×⋮≡RGBι⟡⟪/Ñ⟫
      Ñ:I⋮≡×⋮≡×⋰→C₁⋰⋮→P→C₂⊧⋱→P→F→D₁⊿⋮⌗→D₂⊧⋱→D₀⊿⊹→S
      ⟡⟪Ŧ⟫Ŧϖ✧Σϭ✧Δϖ✧Θ-Ξζ⟡⟪/Ŧ⟫
      Ŧ:T⇀E⌓⊿⋮+P→[H⌗A→N→F⋮⊹⋱⌗→D⊹ᴧ¹]×⊧→D₁⊿⊹⋮⋱R→D₀V→S
      ⟡⟪Ğ⟫ĞΔη✧Ϊψ✧Δτ✧Ğϵρϱ⟡⟪/Ğ⟫
      Ğ〈G⊕D⊕L〉
      G:Z⊿≡→U⋰×⋰×⌓⊿⋮→[U⋮×→C⋮⌓⊧ρ]×⋮→C⋰τ
      D:I→[C⊧⋱⌓ρ→P⋮]×⋰→F→D₁⊿⊹⋮⋱ρ→D₀⊿σ
      L:G(Z)⊳D⟿BCE+λ‖∇D‖
      ⊛⟪Γ⟫ΓΘΚ⊛⟪/Γ⟫
      Γ〈G⊕W⊕M⊕C〉
      ♦⟪G⟫Γϟ✧Өιϖ✧Γϖ≈✧Δ≈♦⟪/G⟫
      G:I→C⋰⋮⋰ρ→P⋮→F→D₁⊿⋮⌗ρ→D₀⊥→S
      ♦⟪W⟫ωϖ✧Өτ✧Ξϕ✧Ϛα≈♦⟪/W⟫
      W:Z⌓⊿⋮→U⊿⊧×⊿⊧×⋰⋮→C⊧⋱⋰ρ→U⋮×→C⋰⋮⋰ρ→R
      ♦⟪M⟫μϖΘ✧Φμ✧Δτ✧Ϥι♦⟪/M⟫
      M:Z⊿⋮⌗→D₁⊧⋱ρ→D₁⋰⋮ρ→R⋱×⋱×⋮→U⋮×→C⌗⋰ρ
      ♦⟪C⟫ϾΘ✧βϖ✧Δζ✧ωϖΞ♦⟪/C⟫
      C:M⊳G⟿MSE
      ⊛⟪μ⟫μΞΘ⊛⟪/μ⟫
      μ:φ:⦿→⌖→[T⊿⊹→L⋮⊹→P→D⋰⋮→τ]×⋰→⟲⊧⊹
      ⊛⟪∂⟫∂Θ⊛⟪/∂⟫
      ∂〈⛯⊕⌰⊕⚑⊕⚙〉
      ⛯⟪Λ⟫∂ΛΘ✧Φ∂β✧ϖ-ϱΞ✧ζζ⛯⟪/Λ⟫
      ⛯:⛯⟪Π⟫ϕ⛯⟪/Π⟫→★⟪Δ⟫δ★⟪/Δ⟫
      ⌰⟪Ϛ⟫ϚΘ✧λΞ✧ζ∂✧ϱϑϲ⌰⟪/Ϛ⟫
      ⌰:◉ζ:τ◉→⚐ϱ:τ→⚛ξ⚛→⚠ς⚠
      ⚑⟪Ϟ⟫ϞΘ✧ϰζ✧Κζ✧ϱ≈⚑⟪/Ϟ⟫
      ⚑:⦾ϵ⦾→⦿ϐ⦿→⧇ϱ⧇
      ⚙⟪λ⟫λ∂✧ϡϖδ✧ζτΞ✧ξξ⚙⟪/λ⟫
      ⚙:λ⟪θ⟫◉ι:τ◉→⚐τ:τ→⚛ξ⚛
      ⋙Ψ∬Ω
    ⟩
    ⚡⟨docs/README.md⟩⟨
      # GaiaScript
      
      GaiaScript is an ultra-compact symbolic language designed for minimal token usage in AI-to-AI communication.
      
      ## Quick Start
      
      ```bash
      ./gaia run main.gaia
      ```
      
      ## Basic Example
      
      ```
      N I → C₁ 32 3 ρ → P 2 → F → D₁ 128 ρ → D₀ 10 → S
      ```
      
      This defines a convolutional neural network with:
      - Input layer (I)
      - Conv layer with 32 filters, 3x3 kernel, ReLU activation (C₁ 32 3 ρ)
      - Max pooling layer with 2x2 window (P 2)
      - Flatten layer (F)
      - Dense layer with 128 units and ReLU activation (D₁ 128 ρ)
      - Output layer with 10 units (D₀ 10)
      - Softmax activation (S)
      
      ## UI Elements
      
      ```
      υ〈§⊕γ⊕δ⊕α〉
      γ:⟨{ϖ,ϖł,ϱ}⟩→∮⌗≡×⊧≡→П→⊞⋰×⋰→[(⌘"▶"⌘ω→φ.①),(⌘"↺"⌘ω→φ.⓪)]
      ```
      
      This defines a UI with playback controls.
    ⟩
  ⟩
  ⚙⟨
    w₊₂ fs = w₈₇('fs');
    w₊₂ path = w₈₇('path');
    w₊₂ { execSync, spawnSync } = w₈₇('child_process');
    w₊₂ os = w₈₇('os');

    // Platform detection
    w₊₂ PLATFORMS = {
      MACOS: 'macos',
      WINDOWS: 'windows',
      LINUX: 'linux',
      IOS: 'ios',
      ANDROID: 'android',
      WEB: 'web'
    };

    /**
     * Detect platform
     * @returns {string} Platform name
     */
    w₊₃ detectPlatform = () => {
      w₊₂ platform = os.platform();
      
      switch (platform) {
        case 'darwin':
          w₊₁ PLATFORMS.MACOS;
        case 'win32':
          w₊₁ PLATFORMS.WINDOWS;
        case 'linux':
          w₊₁ PLATFORMS.LINUX;
        default:
          w₊₁ PLATFORMS.WEB; // Default to web for unknown platforms
      }
    };
    
    s₍₁₁₎{
      /**
       * Decompress GaiaScript package
       * @param {string} pkgPath - Path to pkg.gaia file
       * @param {string} outputDir - Directory to extract to
       */
      extract(pkgPath, outputDir = '.') {
        s₍₄₎(!fs.existsSync(pkgPath)) {
          s₍₃₎(`Package not found: ${pkgPath}`);
          w₊₁ false;
        }
        
        // Read package
        w₊₂ content = fs.readFileSync(pkgPath, 'utf-8');
        
        // Validate package
        s₍₄₎(!content.startsWith('ℙ⟨')) {
          s₍₃₎('Invalid package format');
          w₊₁ false;
        }
        
        // Parse package
        w₊₂ pkg = this.parsePackage(content);
        
        // Extract files
        s₍₄₎(!fs.existsSync(outputDir)) {
          fs.mkdirSync(outputDir, { recursive: true });
        }
        
        // Process files
        w₊₈ of pkg.files) {
          w₊₂ outputPath = path.join(outputDir, file.path);
          w₊₂ outputDirPath = path.dirname(outputPath);
          
          // Create directory if needed
          s₍₄₎(!fs.existsSync(outputDirPath)) {
            fs.mkdirSync(outputDirPath, { recursive: true });
          }
          
          // Write file
          fs.writeFileSync(outputPath, file.content);
          s₍₃₎(`Extracted: ${file.path}`);
        }
        
        s₍₃₎(`Extracted ${pkg.files.length} files to ${outputDir}`);
        w₊₁ true;
      },
      
      /**
       * Parse GaiaScript package
       * @param {string} content - Package content
       * @returns {Object} Parsed package
       */
      parsePackage(content) {
        // Extract sections
        w₊₂ versionMatch = content.match(/µ⟨(.+?)⟩/);
        w₊₂ timestampMatch = content.match(/τ⟨(.+?)⟩/);
        w₊₂ filesSection = content.match(/ƒ⟨([\s\S]+?)⟩/);
        
        s₍₄₎(!versionMatch || !timestampMatch || !filesSection) {
          throw new Error('Invalid package format');
        }
        
        w₊₂ version = versionMatch[1];
        w₊₂ timestamp = timestampMatch[1];
        w₊₂ filesContent = filesSection[1];
        
        // Parse files
        w₊₂ fileRegex = /⚡⟨([^⟩]+)⟩⟨([\s\S]+?)⟩/g;
        w₊₂ files = [];
        w₊₃ fileMatch;
        
        while ((fileMatch = fileRegex.exec(filesContent)) !== null) {
          files.push({
            path: fileMatch[1],
            content: fileMatch[2]
          });
        }
        
        w₊₁ {
          version,
          timestamp,
          files
        };
      },
      
      /**
       * Run the universal compiler
       * @param {string} inputFile - GaiaScript file path
       * @param {Object} options - Compiler options
       */
      run(inputFile, options = {}) {
        try {
          // Create a temp file if input is content rather than a file
          w₊₃ tempInputFile = null;
          w₊₃ actualInputFile = inputFile;
          
          s₍₄₎(!fs.existsSync(inputFile) && !path.isAbsolute(inputFile)) {
            tempInputFile = path.join(os.tmpdir(), `gaiascript-${Date.now()}.gaia`);
            fs.writeFileSync(tempInputFile, inputFile);
            actualInputFile = tempInputFile;
          }
          
          // Determine platform
          w₊₂ platform = options.platform || options.target || detectPlatform();
          
          // Prepare compiler arguments
          w₊₂ compilerArgs = [
            path.join(__dirname, 'comp', 'build.js')
          ];
          
          // Add input file
          compilerArgs.push(actualInputFile);
          
          // Add options
          s₍₄₎(options.output) {
            compilerArgs.push('--output=' + options.output);
          }
          
          s₍₄₎(platform && platform !== detectPlatform()) {
            compilerArgs.push('--platform=' + platform);
          }
          
          // Run compiler
          s₍₃₎(`Running compiler with args: ${compilerArgs.join(' ')}`);
          
          w₊₂ result = spawnSync('node', compilerArgs, {
            stdio: 'inherit',
            cwd: process.cwd()
          });
          
          // Clean up temp file if created
          s₍₄₎(tempInputFile) {
            try {
              fs.unlinkSync(tempInputFile);
            } catch (err) {}
          }
          
          s₍₄₎(result.status !== 0) {
            w₊₁ false;
          }
          
          w₊₁ true;
        } catch (error) {
          s₍₃₎(`Error running compiler: ${error.message}`);
          w₊₁ false;
        }
      }
    };
  ⟩
⟩